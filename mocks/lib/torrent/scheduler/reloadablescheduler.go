// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/uber/kraken/lib/torrent/scheduler (interfaces: ReloadableScheduler)

package mockscheduler

import (
	gomock "github.com/golang/mock/gomock"
	core "github.com/uber/kraken/core"
	scheduler "github.com/uber/kraken/lib/torrent/scheduler"
	connstate "github.com/uber/kraken/lib/torrent/scheduler/connstate"
	reflect "reflect"
)

// MockReloadableScheduler is a mock of ReloadableScheduler interface
type MockReloadableScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockReloadableSchedulerMockRecorder
}

// MockReloadableSchedulerMockRecorder is the mock recorder for MockReloadableScheduler
type MockReloadableSchedulerMockRecorder struct {
	mock *MockReloadableScheduler
}

// NewMockReloadableScheduler creates a new mock instance
func NewMockReloadableScheduler(ctrl *gomock.Controller) *MockReloadableScheduler {
	mock := &MockReloadableScheduler{ctrl: ctrl}
	mock.recorder = &MockReloadableSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (_m *MockReloadableScheduler) EXPECT() *MockReloadableSchedulerMockRecorder {
	return _m.recorder
}

// BlacklistSnapshot mocks base method
func (_m *MockReloadableScheduler) BlacklistSnapshot() ([]connstate.BlacklistedConn, error) {
	ret := _m.ctrl.Call(_m, "BlacklistSnapshot")
	ret0, _ := ret[0].([]connstate.BlacklistedConn)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BlacklistSnapshot indicates an expected call of BlacklistSnapshot
func (_mr *MockReloadableSchedulerMockRecorder) BlacklistSnapshot() *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "BlacklistSnapshot", reflect.TypeOf((*MockReloadableScheduler)(nil).BlacklistSnapshot))
}

// Download mocks base method
func (_m *MockReloadableScheduler) Download(_param0 string, _param1 core.Digest) error {
	ret := _m.ctrl.Call(_m, "Download", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Download indicates an expected call of Download
func (_mr *MockReloadableSchedulerMockRecorder) Download(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "Download", reflect.TypeOf((*MockReloadableScheduler)(nil).Download), arg0, arg1)
}

// Probe mocks base method
func (_m *MockReloadableScheduler) Probe() error {
	ret := _m.ctrl.Call(_m, "Probe")
	ret0, _ := ret[0].(error)
	return ret0
}

// Probe indicates an expected call of Probe
func (_mr *MockReloadableSchedulerMockRecorder) Probe() *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "Probe", reflect.TypeOf((*MockReloadableScheduler)(nil).Probe))
}

// Reload mocks base method
func (_m *MockReloadableScheduler) Reload(_param0 scheduler.Config) {
	_m.ctrl.Call(_m, "Reload", _param0)
}

// Reload indicates an expected call of Reload
func (_mr *MockReloadableSchedulerMockRecorder) Reload(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "Reload", reflect.TypeOf((*MockReloadableScheduler)(nil).Reload), arg0)
}

// RemoveTorrent mocks base method
func (_m *MockReloadableScheduler) RemoveTorrent(_param0 core.Digest) error {
	ret := _m.ctrl.Call(_m, "RemoveTorrent", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveTorrent indicates an expected call of RemoveTorrent
func (_mr *MockReloadableSchedulerMockRecorder) RemoveTorrent(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "RemoveTorrent", reflect.TypeOf((*MockReloadableScheduler)(nil).RemoveTorrent), arg0)
}

// Stop mocks base method
func (_m *MockReloadableScheduler) Stop() {
	_m.ctrl.Call(_m, "Stop")
}

// Stop indicates an expected call of Stop
func (_mr *MockReloadableSchedulerMockRecorder) Stop() *gomock.Call {
	return _mr.mock.ctrl.RecordCallWithMethodType(_mr.mock, "Stop", reflect.TypeOf((*MockReloadableScheduler)(nil).Stop))
}
